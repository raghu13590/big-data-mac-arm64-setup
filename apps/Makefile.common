# Common Makefile for Docker Compose management of services.
# This Makefile is intended to be included from the top-level Makefile in each service directory.
#
# Features:
# - Manages Docker Compose services for individual projects.
# - Handles dependencies between services.
# - Provides common targets for building, starting, stopping, and cleaning up services.
# - Self-documenting help command.
#
# Usage:
#   make <target>
#
# Example from a service directory (e.g., apps/zookeeper):
#   make up       # Starts zookeeper and its dependencies
#   make down     # Stops zookeeper
#   make health   # Checks the health of zookeeper
#

# Phony targets prevent conflicts with file names
.PHONY: help build build-quick up up-minimal down down-volumes restart logs clean status ps health dependencies init

# Define colors for console output
RED := $(shell tput setaf 1)
GREEN := $(shell tput setaf 2)
YELLOW := $(shell tput setaf 3)
NC := $(shell tput sgr0)

# Export all variables to sub-makes
.EXPORT_ALL_VARIABLES:

# Load environment variables from .env file if it exists
ifneq (,$(wildcard $(CURDIR)/.env))
    include $(CURDIR)/.env
endif

# Ensure PROJECT_NAME is set
ifndef PROJECT_NAME
    $(error PROJECT_NAME is not defined. Please set it in your .env file.)
endif

# Define paths and commands
ROOT_DIR := $(abspath $(CURDIR)/../..)
SCRIPTS_DIR := $(ROOT_DIR)/apps/scripts
COMPOSE_FILE := $(CURDIR)/docker-compose.yml
DOCKER_COMPOSE := docker-compose -f $(COMPOSE_FILE) -p $(PROJECT_NAME)

# Default target
all: help

help: ## Show this help message
	@echo "Usage: make <target>"
	@echo ""
	@echo "Available targets:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?##/ {printf "  %-20s %s\n", "$(YELLOW)"$$1"$(NC)", $$2}' $(MAKEFILE_LIST)

build: ## Build Docker images without using cache
	@echo "$(GREEN)Building Docker images for $(PROJECT_NAME)...$(NC)"
	$(DOCKER_COMPOSE) build --no-cache
	@echo "$(GREEN)Build complete!$(NC)"

build-quick: ## Build Docker images using cache
	@echo "$(GREEN)Building Docker images for $(PROJECT_NAME)...$(NC)"
	$(DOCKER_COMPOSE) build

dependencies: ## Start all dependencies in the correct order
	@if [ -n "$(DEPENDENCIES)" ] && [ "$(DEPENDENCIES)" != "null" ]; then \
		"$(SCRIPTS_DIR)/resolve-deps.sh" "$(PROJECT_NAME)"; \
	fi

up: ## Start all services, including dependencies
	@$(MAKE) dependencies
	@$(MAKE) up-minimal

up-minimal: ## Start services for this project only
	@echo "$(GREEN)\nStarting services for $(PROJECT_NAME)...$(NC)"
	@$(MAKE) init
	$(DOCKER_COMPOSE) up -d
	@echo "$(GREEN)Waiting for services to be healthy...$(NC)"
	@sleep 30
	@$(MAKE) health
	@echo "$(GREEN)Services for $(PROJECT_NAME) are up and healthy!$(NC)"

up-service: ## Start a single service by name: make up-service SERVICE=servicename
	@if [ -z "$(SERVICE)" ]; then \
		echo "$(RED)SERVICE variable not set. Usage: make up-service SERVICE=servicename$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)Starting service: $(SERVICE) for $(PROJECT_NAME)...$(NC)"
	$(DOCKER_COMPOSE) up -d $(SERVICE)
	@sleep 10

init: ## Initialize service-specific resources (override in service Makefile if needed)
	@: # No-op

down: ## Stop all services for this project
	@echo "$(RED)Stopping services for $(PROJECT_NAME)...$(NC)"
	$(DOCKER_COMPOSE) down

down-volumes: ## Stop all services and remove volumes
	@echo "$(RED)Stopping services and removing volumes for $(PROJECT_NAME)...$(NC)"
	$(DOCKER_COMPOSE) down -v

restart: ## Restart all services
	@$(MAKE) down
	@$(MAKE) up

logs: ## View logs for all services
	@echo "$(GREEN)Viewing logs for $(PROJECT_NAME)...$(NC)"
	$(DOCKER_COMPOSE) logs -f

clean: ## Remove unused Docker resources
	@echo "$(RED)Cleaning up unused Docker resources...$(NC)"
	docker system prune -f

status: ## List running services for this project
	@echo "$(GREEN)Listing running services for $(PROJECT_MAME)...$(NC)"
	$(DOCKER_COMPOSE) ps

ps: status ## Alias for status

health: ## Check the health status of all components
	@echo "$(GREEN)Checking health status for $(PROJECT_NAME)...$(NC)"
	@services=$$($(DOCKER_COMPOSE) ps --services); \
	for service in $$services; do \
		health_status=$$(docker inspect --format='{{.State.Health.Status}}' $$($(DOCKER_COMPOSE) ps -q $$service) 2>/dev/null); \
		if [ "$$health_status" = "unhealthy" ]; then \
			echo "$(RED)Service $$service is unhealthy.$(NC)"; \
			exit 1; \
		elif [ "$$health_status" != "healthy" ]; then \
			echo "$(YELLOW)Service $$service is not healthy (status: $$health_status), but continuing...$(NC)"; \
		fi; \
	done
	@echo "$(GREEN)All components are healthy!$(NC)"

health-service: ## Check the health status of a single service: make health-service SERVICE=servicename
	@echo "Checking health for service: $(SERVICE)"
	@if [ -z "$(SERVICE)" ]; then \
		echo "SERVICE variable not set. Usage: make health-service SERVICE=servicename"; \
		exit 1; \
	elif ! service_id=$$($(DOCKER_COMPOSE) ps -q $(SERVICE)); then \
		echo "Service $(SERVICE) not found."; \
		exit 1; \
	elif [ -z "$$service_id" ]; then \
		echo "Service $(SERVICE) is not running."; \
		exit 1; \
	else \
		echo "Inspecting health status for $(SERVICE)..."; \
		health_status=$$(docker inspect --format='{{.State.Health.Status}}' $$service_id 2>/dev/null); \
		echo "Health status: $$health_status"; \
		echo "$$health_status"; \
	fi; \
	exit 0

health-service-retry:
	@attempts=0; \
	while [ $$attempts -lt 10 ]; do \
		status=$$($(MAKE) --no-print-directory health-service SERVICE=$(SERVICE) | tail -n 1); \
		echo "Result from health-service: $$status"; \
		if [ "$$status" = "healthy" ]; then \
			echo "Service $(SERVICE) is healthy."; \
			exit 0; \
		elif [ "$$status" = "unhealthy" ]; then \
			echo "Service $(SERVICE) is unhealthy. Exiting."; \
			exit 1; \
		elif [ "$$status" = "starting" ]; then \
			echo "Service $(SERVICE) is starting. Attempt $$((attempts+1))/10. Retrying in 15 seconds..."; \
			sleep 15; \
		else \
			echo "Unknown health status: $$status. Exiting."; \
			exit 1; \
		fi; \
		attempts=$$((attempts+1)); \
	done; \
	echo "Service $(SERVICE) failed to become healthy after 10 attempts."; \
	exit 1