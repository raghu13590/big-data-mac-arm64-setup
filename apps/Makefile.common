# Top-level Makefile for Docker Compose management
# Usage:
#   make -C <service_dir> <target>
# Example:
#   make -C apps/zookeeper up
#   make -C apps/zookeeper down
#   make -C apps/zookeeper health
#
# The -C option ensures that the Makefile in the specified directory is used,
# allowing you to run commands from any directory.
.PHONY: help build build-quick up up-minimal down restart logs clean status health

# Colors for output
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[1;33m
NC = \033[0m # No Color

export RED GREEN YELLOW NC

# Reset DEPENDENCIES before including .env
DEPENDENCIES=
# Load .env file for each project
ifneq (,$(wildcard $(CURDIR)/.env))
    include $(CURDIR)/.env
    export
endif

# PROJECT_NAME is required in .env file which should match the directory name
ifndef PROJECT_NAME
$(error PROJECT_NAME is not defined. Please set it in your .env file or environment and should match the directory name.)
endif
MAKEFILE_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))
# docker-compose.yml is expected to be in the directory with PROJECT_NAME defined in .env
COMPOSE_FILE := $(MAKEFILE_DIR)docker-compose.yml

DOCKER_COMPOSE = docker-compose -f $(COMPOSE_FILE) -p $(PROJECT_NAME)

help: ## Show this help message
	@echo "${GREEN}Top-Level Makefile for Docker Compose Management${NC}"
	@echo ""
	@echo "Usage:"
	@echo "  ${YELLOW}make -C <service_dir> <target>${NC}"
	@echo ""
	@echo "Examples:"
	@echo "  ${YELLOW}make -C apps/zookeeper up${NC}"
	@echo "  ${YELLOW}make -C apps/zookeeper down${NC}"
	@echo "  ${YELLOW}make -C apps/zookeeper health${NC}"
	@awk 'BEGIN {FS = ":.*?## "} { \
		if (/^[a-zA-Z_-]+:.*?##/) \
			printf "  ${YELLOW}%-20s${NC} %s\n", $$1, $$2 \
	}' $(MAKEFILE_LIST)

build: ## Build Docker images (no cache)
	@echo "${GREEN}Building Docker images for $(PROJECT_NAME)...${NC}"
	$(DOCKER_COMPOSE) build --no-cache
	@echo "${GREEN}Build complete!${NC}"

build-quick: ## Quick build (uses cache)
	@echo "${GREEN}Building Docker images for $(PROJECT_NAME)...${NC}"
	$(DOCKER_COMPOSE) build

dependencies: ## Start all dependencies recursively with cycle detection and chain logging
	@echo "${YELLOW}DEBUG: In dependencies target${NC}"
	@if [ -n "$(DEPENDENCIES)" ] && [ "$(DEPENDENCIES)" != "null" ]; then \
	    echo "${YELLOW}DEBUG: CURDIR=$(CURDIR)${NC}"; \
        echo "${YELLOW}DEBUG: PROJECT_NAME=$(PROJECT_NAME)${NC}"; \
        echo "${YELLOW}DEBUG: DEPENDENCIES=$(DEPENDENCIES)${NC}"; \
		visited_file="/tmp/visited_$$.txt"; \
		trap "rm -f $$visited_file" EXIT; \
		touch $$visited_file; \
		start_deps() { \
			local deps="$$1"; \
			local chain="$$2"; \
			for dep in $$(echo $$deps | tr ',' ' '); do \
				if grep -qw "$$dep" $$visited_file; then \
					echo "${YELLOW}DEBUG: Skipping already processed dependency: $$dep${NC}"; \
					continue; \
				fi; \
				if [ "$$dep" = "$(PROJECT_NAME)" ]; then \
					echo "${RED}Error: Project $(PROJECT_NAME) cannot depend on itself.${NC}"; \
					exit 1; \
				fi; \
				dep_dir=$$(find .. -type f -name ".env" -exec grep -l "PROJECT_NAME=$$dep" {} + | xargs dirname | head -n 1); \
				if [ -z "$$dep_dir" ]; then \
					echo "${RED}Error: Could not find directory for dependency: $$dep${NC}"; \
					exit 1; \
				fi; \
				echo "${GREEN}DEBUG: Dependency chain: $$chain -> $$dep${NC}"; \
				dep_env=$$(cat $$dep_dir/.env | grep "^DEPENDENCIES=" | cut -d'=' -f2); \
				if [ -n "$$dep_env" ] && [ "$$dep_env" != "null" ]; then \
					start_deps "$$dep_env" "$$chain -> $$dep"; \
				fi; \
				echo "$$dep" >> $$visited_file; \
				echo "${GREEN}DEBUG: Starting dependency: $$dep in directory: $$dep_dir...${NC}"; \
				$(MAKE) -C $$dep_dir up || exit 1; \
			done; \
		}; \
		start_deps "$(DEPENDENCIES)" "$(PROJECT_NAME)"; \
	fi

up: ## Start all services with dependencies, initialization and health checks
	@echo "${YELLOW}DEBUG: In up target${NC}"
	@$(MAKE) dependencies
	@echo "${YELLOW}DEBUG: COMPOSE_FILE=$(COMPOSE_FILE)${NC}"
	@echo "${YELLOW}DEBUG: PROJECT_NAME=$(PROJECT_NAME)${NC}"
	@echo "${YELLOW}DEBUG: CURDIR=$(CURDIR)${NC}"
	@echo "${GREEN}\nStarting services for $(PROJECT_NAME)...${NC}"
	@$(MAKE) init
	$(DOCKER_COMPOSE) up -d
	@echo "${GREEN}Waiting for services to be healthy...${NC}"
	sleep 30
	@$(MAKE) health COMPOSE_FILE=$(COMPOSE_FILE) PROJECT_NAME=$(PROJECT_NAME)
	@echo "${GREEN}Services are up!${NC}"

init: ## override in service-specific Makefile if needed

down: ## Stop all services
	@echo "${RED}Stopping services for $(PROJECT_NAME)...${NC}"
	$(DOCKER_COMPOSE) down

restart: down up ## Restart all services

logs: ## View logs
	@echo "${GREEN}Viewing logs for $(PROJECT_NAME)...${NC}"
	$(DOCKER_COMPOSE) logs -f

clean: ## Remove unused Docker resources
	@echo "${RED}Cleaning up unused Docker resources...${NC}"
	docker system prune -f

status: ## List running services
	@echo "${GREEN}Listing running services for $(PROJECT_NAME)...${NC}"
	$(DOCKER_COMPOSE) ps

health: ## Check health status of all components
	@echo "${GREEN}Checking health status of components for $(PROJECT_NAME)...${NC}"
	@for service in $$($(DOCKER_COMPOSE) ps --services); do \
		status=$$(docker inspect --format='{{json .State.Health.Status}}' $$($(DOCKER_COMPOSE) ps -q $$service) 2>/dev/null); \
		if [ "$$status" != "\"healthy\"" ]; then \
			echo "Service $$service is not healthy (status: $$status). Check logs for details."; \
			exit 1; \
		fi; \
	done; \
	echo "All components are healthy!"
